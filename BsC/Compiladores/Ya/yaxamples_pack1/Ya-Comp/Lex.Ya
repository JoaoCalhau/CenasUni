@Ya/Lex; // Lexemas
// 13 Oct, 12 Sept, Mar, Jan

`Int+- YLexsLength = 256
`Int+- YLexNo = YLexsLength-1
#define _Lex Lexes->Lex.Lex // don't know how to for it

\`YLex_ = `Char; // unsigned
\`YLex = enum `YLex_; // yet not defined just here

\`LexFix_ = bits 32 // 32 max bits allowed
	f0=nobits,
	fOperand =0,
	fe, fTypeCastFunc =19,
	fes fPost =4,
	fese fIn=2,
	feses fCall=15,
	feses_ fCall_=16,
	fesese fIf=10,
	fesese_ fElse=11,
	//fs, // fSign == just sign, like varfunc - should be allowed 0s
	fse fPre=1,
	fses fBracket=13,
	fses_ fBracket_=14,
	fsese=17, // fAroundTail 0sese
	fsese_=18, // fAroundTail_
	fRoundOpen =6, fRoundClose =7, fSquareOpen =8, fSquareClose =9, // better to remove them, yet it requires extra code under case fBracket:
	// - wow, move it under ExprLex. fLalaOpen+Close will be yet not in .LL1  ???
	//fIf =10, fElse =11, 
	fInIn =3, fInfix2Field =5, fTypeCast =12, 
	fAllPre=fPre|fBracket, fAllIn=fIn|fInIn|fCall, fAllPost=fPost|fBracket_|fsese_|feses_, // looks like it's impossible. Requires to change parsing of 'bits'
	//fAround =13, fAroundEnd =14, fCallAlike =15, fCallAlikeEnd =16,
	fOut =27, fIdent=28, fOrderR2L =29, fStat =30, fTyper =31,

\`LexPriority = `byte
\`LexFix = `Int+

\`YLexema
	`LexFix(LexFix f, LexFix baseF, LexPriority pr) FixPr_
	void(LexFix f, LexPriority pr) FixPr
	void(YLex_ lex, chars name, LexFix f, LexPriority pr) Set; // pr for all in f
	void(LexFix f, LexPriority pr) Set
		FixPr(f, pr)
	chars() Text = chars(Text_, TextLength)
	LexPriority(LexFix f) Pr
		Switch(f)
			default: bug()
			case 0: ;Return 0
			case fses: // open bracket
			case fse: ;Return PrPre
			case feses: // fCall
			case fese: ;Return PrIn
			case fes: ;Return PrPost

	YLex Lex :8
	int TextLength :8
	charz Text_
	LexFix F
	LexPriority PrPre, PrIn, PrPost
	YLex LexBack :8

void(YLex_ lex, LexFix f, LexPriority pr) YLexemaSet
YLexema Lexemas[YLexsLength]; // static global array, generated by LL1.exe
uchar *In, *LexemaStart
Str LexemaText

\`YLexa
	YLexa(YLexema& lex, Str at) : Lex(lex) { At = at; }
	YLexa(YLexema& lex, uchars at) : Lex(lex) { At = (chars)at; }
	//YLexa(YLexema& lex, Str at) : Lex(lex) { At = (uchars)at; }
	//YLexa(YLexema& lex, uchars at) : Lex(lex) { At = at; }
	YLexa() : Lex(*(YLexema*)this) { At = 0; }
	YLexa(YLexa& l) : Lex(Lexemas[l.Lex.Lex]) { At = l.At; }
	void operator = (YLexa& b){ memcpy(this, &b, sizeof(*this)); /*&Lex = &b.Lex; At = b.At;*/ }

	YLexema& Lex
	Str At
	//uchars At

void(YLex) Skip
void(YLex req, charz format, ...) Skip
`Bool(YLex) SkipIf
void() IncorrectLexema
void() IncorrectInsideLexema
void() IncorrectSyn
YLex() LexemaCheck
YLex() Lexema
YLex() LexemaForLexes
inline uchars() LexemaTextLast
int NExpressions
